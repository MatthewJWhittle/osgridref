dplyr::mutate(out_x = xmin + in_x,
out_y = ymin + in_y)
# Select and rename variables for clean output
out_coords <-
out_coords %>%
dplyr::select(x = out_x, y = out_y, resolution)
# This could return a spatial object but would have to deal with NA values
return(out_coords)
}
osgridref_to_xy(grid_refs)
library(osgridref)
document
document()
require(devtools)
document
document()
build()
library(osgridref)
build()
library(osgridref)
gridref_to_xy(grid_refs)
build()
library(osgridref)
osgridref::osgridref_to_xy()
install("osgridref")
setwd("..")
install("osgridref")
install("osgridref")
setwd("osgridref")
grid_refs <- c("TA 304 403", "SE 2344 0533", "SE13", "SE 234444 053344")
gridref_to_xy(grid_refs)
library(osgridref)
grid_refs <- c("TA 304 403", "SE 2344 0533", "SE13", "SE 234444 053344")
gridref_to_xy(grid_refs)
devtools::install_github("matthewjwhittle/osgridref")
?gridref_to_xy
toupper("ab")
?grep()
grep("a", "abc")
grep("[0-9]", "abc1")
grepl("[0-9]", "abc1")
document()
build()
devtools::install_github("matthewjwhittle/osgridref")
devtools::install_github("matthewjwhittle/osgridref", force = T)
devtools::install_github("matthewjwhittle/osgridref")
library(osgridref)
osgb_to_xy()
osgb_to_xy("SE1221")
.Deprecated
?.Deprecated
library(osgridref)
osgb_to_xy("SE1221")
usethis::use_testthat()
require(osgridref)
x <- c("SE 123 356")
result <- gridref_to_xy(x)
result
expected_result <- tibble(x = 412300, y = 435600, resolution = 100)
require(testthat)
require(osgridref)
x <- c("SE 123 356")
result <- gridref_to_xy(x)
expected_result <- tibble(x = 412300, y = 435600, resolution = 100)
require(dplyr)
expected_result <- tibble(x = 412300, y = 435600, resolution = 100)
expect_equal(result, expected_result)
result
expected_result
x <- c("SE12233355")
result <- gridref_to_xy(x)
result
expected_result <- tibble(x = 412230, y = 433550, resolution = 10)
expect_equal(result, expected_result)
x <- c(140)
result <- gridref_to_xy(x)
result
usethis::use_build_ignore("development")
x <- c(2124)
#gridref_to_xy <- function(x) {
# Get the square letters and numbers using regex
square_letters <- toupper(str_extract(x, "^[a-zA-Z]{2}"))
numbers <- str_extract(x, "[0-9]+ ?[0-9]+") %>% str_remove_all(" ")
square_letters
#gridref_to_xy <- function(x) {
# Get the square letters and numbers using regex
square_letters <- toupper(str_extract(x, "^[a-zA-Z]{2}"))
require(tidyverse)
x <- c(2124)
#gridref_to_xy <- function(x) {
# Get the square letters and numbers using regex
square_letters <- toupper(str_extract(x, "^[a-zA-Z]{2}"))
numbers <- str_extract(x, "[0-9]+ ?[0-9]+") %>% str_remove_all(" ")
square_letters
nchar(square_letters) == 2
# Test that the square letters have been extracted properly
missing_letters <- is.na(square_letters)
bad_format_letters <- nchar(square_letters) == 2
# Create a null return
null_conversion <- tibble(x = NA, y = NA, resolution = NA)
bad_format_letters
bad_format_letters <- if_else(is.na(bad_format_letters),
true = TRUE, false = bad_format_letters)
bad_format_letters
bad_format_letters <- is.na(square_letters) || nchar(square_letters) == 2
bad_format_letters
numbers
# Set invalid grid references to NA
numbers[uneven_digits] <- NA
# Split for later addition
coord_digits <- digits / 2
# Create a null return
null_conversion <- tibble(x = NA, y = NA, resolution = NA)
# Split the numbers into x and y
# Get the resolution from number of digits
digits <- nchar(numbers)
uneven_digits <- !(digits %% 2 == 0)
# Set invalid grid references to NA
numbers[uneven_digits] <- NA
# Split for later addition
coord_digits <- digits / 2
grid_x <- substr(numbers, 1, coord_digits)
grid_y <- substr(numbers, coord_digits + 1, digits)
# Calculate the resolution
resolution <- 10 ^ (5 - coord_digits)
x_num <- as.numeric(grid_x) * resolution
y_num <- as.numeric(grid_y) * resolution
# Set invalid grid references to NA
numbers[uneven_digits | bad_format_letters] <- NA
numbers
# Split for later addition
coord_digits <- digits / 2
grid_x <- substr(numbers, 1, coord_digits)
grid_y <- substr(numbers, coord_digits + 1, digits)
# Calculate the resolution
resolution <- 10 ^ (5 - coord_digits)
x_num <- as.numeric(grid_x) * resolution
y_num <- as.numeric(grid_y) * resolution
# Build a tibble of in data
in_coords <-
dplyr::tibble(
in_letters = square_letters,
in_ref = x,
resolution = resolution,
in_x = x_num,
in_y = y_num
)
# Get the osgb square lookup
lookup <- osgb_lookup() %>%
dplyr::mutate(
xmin = as.numeric(paste0(x, "00000")),
ymin = as.numeric(paste0(y, "00000"))
)
require(osgridref)
# Get the osgb square lookup
lookup <- osgb_lookup() %>%
dplyr::mutate(
xmin = as.numeric(paste0(x, "00000")),
ymin = as.numeric(paste0(y, "00000"))
)
osgb_lookup <- function() {
letter1 <- list(
"S" = c(0, 0),
"T" = c(5, 0),
"N" = c(0, 5),
"H" = c(0, 10),
"O" = c(5, 5)
)
letter1 <- do.call(rbind, letter1)
letter2 <- list(
"A" = c(y = 4, x = 0),
"B" = c(4, 1),
"C" = c(4, 2),
"D" = c(4, 3),
"E" = c(4, 4),
"F" = c(3, 0),
"G" = c(3, 1),
"H" = c(3, 2),
"J" = c(3, 3),
"K" = c(3, 4),
"L" = c(2, 0),
"M" = c(2, 1),
"N" = c(2, 2),
"O" = c(2, 3),
"P" = c(2, 4),
"Q" = c(1, 0),
"R" = c(1, 1),
"S" = c(1, 2),
"T" = c(1, 3),
"U" = c(1, 4),
"V" = c(0, 0),
"W" = c(0, 1),
"X" = c(0, 2),
"Y" = c(0, 3),
"Z" = c(0, 4)
)
letter2 <- do.call(rbind, letter2)[, c("x", "y")]
square_letter1 <- rownames(letter1)
square_letter2 <- rownames(letter2)
lookup_list <-
lapply(
c(1:dim(letter1)[1]),
function(i) {
numbers <- letter1[i,] + letter2
cbind.data.frame(square_letters = paste0(square_letter1[i], square_letter2), numbers, stringsAsFactors = F)
}
)
lookup <- as.data.frame(do.call(rbind, lookup_list), stringsAsFators = FALSE)
return(lookup)
}
# Get the osgb square lookup
lookup <- osgb_lookup() %>%
dplyr::mutate(
xmin = as.numeric(paste0(x, "00000")),
ymin = as.numeric(paste0(y, "00000"))
)
in_coords
lookup
# Build a tibble of in data
in_coords <-
dplyr::tibble(
in_letters = square_letters,
in_ref = as.character(x),
resolution = resolution,
in_x = x_num,
in_y = y_num
)
# Get the osgb square lookup
lookup <- osgb_lookup() %>%
dplyr::mutate(
xmin = as.numeric(paste0(x, "00000")),
ymin = as.numeric(paste0(y, "00000"))
)
lookup
# Perform a joins operation to match up the grid refs with their squares
out_coords <-
in_coords %>%
dplyr::left_join(lookup,
by = c("in_letters" = "square_letters")) %>%
dplyr::mutate(out_x = xmin + in_x,
out_y = ymin + in_y)
out_coords
# Select and rename variables for clean output
out_coords <-
out_coords %>%
dplyr::select(x = out_x, y = out_y, resolution)
out_coords
iris
rows <- nrow(iris)
set.seed(1)
logical <- sample(c(TRUE, FALSE), size = rows, replace = TRUE)
rows <- nrow(iris)
set.seed(1)
logical <- sample(c(TRUE, FALSE), size = rows, replace = TRUE)
iris[logical]
iris[logical, ]
iris[logical, ] <- NA
iris
invalid_ref <- uneven_digits | bad_format_letters
#gridref_to_xy <- function(x) {
# Get the square letters and numbers using regex
square_letters <- toupper(str_extract(x, "^[a-zA-Z]{2}"))
numbers <- str_extract(x, "[0-9]+ ?[0-9]+") %>% str_remove_all(" ")
# Create a null return
null_conversion <- tibble(x = NA, y = NA, resolution = NA)
# Split the numbers into x and y
# Get the resolution from number of digits
digits <- nchar(numbers)
uneven_digits <- !(digits %% 2 == 0)
# Test that the square letters have been extracted properly
bad_format_letters <- is.na(square_letters) || nchar(square_letters) == 2
invalid_ref <- uneven_digits | bad_format_letters
invalid_ref
invalid_ref <- uneven_digits | bad_format_letters
# Set invalid grid references to NA
numbers[invalid_ref] <- NA
# Split for later addition
coord_digits <- digits / 2
grid_x <- substr(numbers, 1, coord_digits)
grid_y <- substr(numbers, coord_digits + 1, digits)
# Calculate the resolution
resolution <- 10 ^ (5 - coord_digits)
x_num <- as.numeric(grid_x) * resolution
y_num <- as.numeric(grid_y) * resolution
# Build a tibble of in data
in_coords <-
dplyr::tibble(
in_letters = square_letters,
in_ref = as.character(x),
resolution = resolution,
in_x = x_num,
in_y = y_num
)
# Get the osgb square lookup
lookup <- osgb_lookup() %>%
dplyr::mutate(
xmin = as.numeric(paste0(x, "00000")),
ymin = as.numeric(paste0(y, "00000"))
)
# Perform a joins operation to match up the grid refs with their squares
out_coords <-
in_coords %>%
dplyr::left_join(lookup,
by = c("in_letters" = "square_letters")) %>%
dplyr::mutate(out_x = xmin + in_x,
out_y = ymin + in_y)
# Select and rename variables for clean output
out_coords <-
out_coords %>%
dplyr::select(x = out_x, y = out_y, resolution)
out_coords[invalid_ref, ] <- NA
out_coords
warning(paste0(sum(invalid_ref)))
warning(paste0(sum(invalid_ref), mean(invalid_ref)))
warning(paste0(sum(invalid_ref), round(mean(invalid_ref) * 100), "%", " failed to parse" ))
warning(paste0(sum(invalid_ref), " (", round(mean(invalid_ref) * 100), "%)", "grid references failed to parse" ))
warning(paste0(sum(invalid_ref), " (", round(mean(invalid_ref) * 100), "%) ", "grid references failed to parse" ))
require(tidyverse)
require(osgridref)
x <- c(2124)
#gridref_to_xy <- function(x) {
# Get the square letters and numbers using regex
square_letters <- toupper(str_extract(x, "^[a-zA-Z]{2}"))
numbers <- str_extract(x, "[0-9]+ ?[0-9]+") %>% str_remove_all(" ")
# Create a null return
null_conversion <- tibble(x = NA, y = NA, resolution = NA)
# Split the numbers into x and y
# Get the resolution from number of digits
digits <- nchar(numbers)
uneven_digits <- !(digits %% 2 == 0)
# Test that the square letters have been extracted properly
bad_format_letters <- is.na(square_letters) || nchar(square_letters) == 2
invalid_ref <- uneven_digits | bad_format_letters
# Set invalid grid references to NA
numbers[invalid_ref] <- NA
# Split for later addition
coord_digits <- digits / 2
grid_x <- substr(numbers, 1, coord_digits)
grid_y <- substr(numbers, coord_digits + 1, digits)
# Calculate the resolution
resolution <- 10 ^ (5 - coord_digits)
x_num <- as.numeric(grid_x) * resolution
y_num <- as.numeric(grid_y) * resolution
# Build a tibble of in data
in_coords <-
dplyr::tibble(
in_letters = square_letters,
in_ref = as.character(x),
resolution = resolution,
in_x = x_num,
in_y = y_num
)
# Get the osgb square lookup
lookup <- osgb_lookup() %>%
dplyr::mutate(
xmin = as.numeric(paste0(x, "00000")),
ymin = as.numeric(paste0(y, "00000"))
)
# Perform a joins operation to match up the grid refs with their squares
out_coords <-
in_coords %>%
dplyr::left_join(lookup,
by = c("in_letters" = "square_letters")) %>%
dplyr::mutate(out_x = xmin + in_x,
out_y = ymin + in_y)
# Select and rename variables for clean output
out_coords <-
out_coords %>%
dplyr::select(x = out_x, y = out_y, resolution)
if(any(invalid_ref)){
out_coords[invalid_ref, ] <- NA
warning(paste0(sum(invalid_ref), " (", round(mean(invalid_ref) * 100), "%) ", "grid references failed to parse" ))
}
# This could return a spatial object but would have to deal with NA values
return(out_coords)
#}
warning(paste0(sum(invalid_ref), "grid references failed to parse" ))
is.vector(x)
is.character(x)
character_vector <- is.vector(x) || is.character(x)
if(!character_vector){
stop("x is not a charactor vector")
}
# Test that x is a character vector
character_vector <- is.vector(x) || is.character(x)
character_vector
# Test that x is a character vector
character_vector <- is.vector(x) && is.character(x)
character_vector
# Test that x is a character vector
character_vector <- is.vector(x) && is.numeric(x)
character_vector
# Test that x is a character vector
character_vector <- is.vector(x) && is.character(x)
character_vector
if(!character_vector){
stop("x is not a charactor vector")
}
x <- as.numeric(140)
x
gridref_to_xy(x)
expect_error(gridref_to_xy(x))
load_all()
require(devtools)
load_all()
expect_error(gridref_to_xy(x))
data.frame(c1 = c(0, 2, 4), c2 = c("a", "b", "c"))
df <- data.frame(c1 = c(0, 2, 4), c2 = c("a", "b", "c"))
gridref_to_xy(df)
x <-
c("SE123320", "TA203523", "102302")
gridref_to_xy(x)
x <-
c("SE123320", "TA203523")
x <-
c("SE123320", "TA203523")
gridref_to_xy(x)
# Assert that x is a character vector
character_vector <- is.vector(x) && is.character(x)
if(!character_vector){
stop("x is not a character vector")
}
# Get the square letters and numbers using regex
square_letters <- toupper(str_extract(x, "^[a-zA-Z]{2}"))
numbers <- str_extract(x, "[0-9]+ ?[0-9]+") %>% str_remove_all(" ")
numbers
# Create a null return
null_conversion <- tibble(x = NA, y = NA, resolution = NA)
null_conversion
square_letters
x <-
c("SE123320", "TA203523", "102302")
# Get the square letters and numbers using regex
square_letters <- toupper(str_extract(x, "^[a-zA-Z]{2}"))
square_letters
numbers <- str_extract(x, "[0-9]+ ?[0-9]+") %>% str_remove_all(" ")
# Create a null return
null_conversion <- tibble(x = NA, y = NA, resolution = NA)
# Split the numbers into x and y
# Get the resolution from number of digits
digits <- nchar(numbers)
uneven_digits <- !(digits %% 2 == 0)
uneven_digits
digits
# Test that the square letters have been extracted properly
bad_format_letters <- is.na(square_letters) || nchar(square_letters) == 2
bad_format_letters
is.na(square_letters)
nchar(square_letters) == 2
# Test that the square letters have been extracted properly
bad_format_letters <- is.na(square_letters) || (nchar(square_letters) == 2)
bad_format_letters
is.na(square_letters)
is.na(square_letters) || (nchar(square_letters) == 2)
# Test that the square letters have been extracted properly
bad_format_letters <- is.na(square_letters) | (nchar(square_letters) == 2)
bad_format_letters
# Check for test failure
invalid_ref <- uneven_digits || bad_format_letters
invalid_ref
# Check for test failure
invalid_ref <- uneven_digits | bad_format_letters
invalid_ref
load_all()
x <-
c("SE123320", "TA203523", "102302")
expect_warning(gridref_to_xy(x))
gridref_to_xy(x)
# Assert that x is a character vector
character_vector <- is.vector(x) && is.character(x)
if(!character_vector){
stop("x is not a character vector")
}
# Get the square letters and numbers using regex
square_letters <- toupper(str_extract(x, "^[a-zA-Z]{2}"))
numbers <- str_extract(x, "[0-9]+ ?[0-9]+") %>% str_remove_all(" ")
# Create a null return
null_conversion <- tibble(x = NA, y = NA, resolution = NA)
# Split the numbers into x and y
# Get the resolution from number of digits
digits <- nchar(numbers)
uneven_digits <- !(digits %% 2 == 0)
uneven_digits
# Test that the square letters have been extracted properly
bad_format_letters <- is.na(square_letters) | (nchar(square_letters) == 2)
bad_format_letters
is.na(square_letters)
(nchar(square_letters) == 2)
nchar(square_letters)
nchar(square_letters) == 2
# Test that the square letters have been extracted properly
bad_format_letters <- is.na(square_letters) | !(nchar(square_letters) == 2)
bad_format_letters
load_all(*)
load_all()
x <-
c("SE123320", "TA203523", "102302")
expect_warning(gridref_to_xy(x))
gridref_to_xy(x)
resolution = c(100, 100, NA)
expected_result <- tibble(x = c(412300, 520300, NA),
y = c(432000, 452300, NA),
resolution = c(100, 100, NA))
expect_equal(gridref_to_xy(x), expected_result)
x <-
c("SE123320", "TA203523", "102302")
expect_warning(gridref_to_xy(x))
expected_result <- tibble(x = c(412300, 520300, NA),
y = c(432000, 452300, NA),
resolution = c(100, 100, NA))
expect_equal(gridref_to_xy(x), expected_result)
build()
